#include "ros/ros.h"
#include "opencv2/opencv.hpp"
#include "image_transport/image_transport.h"
#include "sensor_msgs/image_encodings.h"
#include "cv_bridge/cv_bridge.h"
#include "arm/Angle.h"

class tracker_sb
{
    public:

        tracker_sb()
            :it(nh)
        {

            pub_tracked = it.advertise("arm/tracking", 1);
            sub_raw = it.subscribe("arm/frame_raw", 1, &tracker_sb::frame_raw_callback, this);
            //sub_thresh = it.subscribe("arm/thresholded_frame", 1, &tracker_sb::thresholded_frame_callback, this);

            //pub_Joints = n.advertise<arm::Angle>("tracker", 1);

            noise = 1000;
        }

        void frame_raw_callback(sensor_msgs::ImageConstPtr& frame_raw)
        {
            try
            {
                bridge_Raw = cv_bridge::toCvCopy(frame_raw, sensor_msgs::image_encodings::BGR8);
            }
            catch(cv_bridge::Exception& e)
            {
                ROS_ERROR("cv_bridge execption: %s", e.what());
            }
        }

        void thresholded_frame_callback(sensor_msgs::ImageConstPtr& thresholded_frame)
        {
            cv_bridge::CvImagePtr cv_ptr;
            try
            {
                cv_ptr = cv_bridge::toCvCopy(thresholded_frame, sensor_msgs::image_encodings::MONO8);                                
            }
            catch(cv_bridge::Exception& e)
            {
                ROS_ERROR("cv_bridge exception: %s", e.what());
                exit(0);
            }

            cv::Moments moment= cv::moments(cv_ptr->image, true);

            double moment10 = moment.m10;
            double moment01 = moment.m01;
            double area = moment.m00;


            if(area < noise)
            {
                last_XPos = -1;
                last_YPos = -1;
                current_XPos = -1;
                current_YPos = -1;
            }
            else
            {
                current_XPos = moment10/area;
                current_YPos = moment01/area;
            }

            if(current_XPos >= 0 && current_YPos >= 0 && last_XPos >= 0 && last_YPos >= 0)
            {
                cv::line(bridge_Raw->image, cv::Point(current_XPos, current_YPos), cv::Point(last_XPos, last_YPos), cv::Scalar(0, 0, 255), 4);
            }

            pub_tracked.publish(bridge_Raw->toImageMsg());

            last_XPos = current_XPos;
            last_YPos = current_YPos;

        }

    private:

        arm::Angle jointsRAngles;
        
        ros::NodeHandle nh;

        image_transport::ImageTransport it;

        image_transport::Subscriber sub_raw;
        //image_transport::Subscriber sub_thresh;

        image_transport::Publisher pub_tracked;

        ros::Publisher pub_Joints;

        cv_bridge::CvImagePtr bridge_Raw;

        int noise;
            
        int last_XPos, last_YPos, current_XPos, current_YPos;

};

int main(int argc, char **argv)
{
    ros::init(argc, argv, "tracker");

    tracker_sb track;

    ros::spin();

    return 0;
}
